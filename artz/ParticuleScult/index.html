<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kinetic Particle "R" Sculpture</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        canvas { display: block; }
        #overlay {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="overlay">Arrows / 2-Finger Slide to rotate • +/- / Pinch to zoom • Tap 5x to Explode</div>

    <script type="importmap">
        {
            "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const PARTICLE_COUNT = 7500;
        const MOUSE_INFLUENCE = 10.0;
        const EXPLOSION_RECOVERY_TIME = 10000;
        
        let scene, camera, renderer, particles;
        let particleData = [];
        let mouseWorld = new THREE.Vector3(-1000, -1000, 0);
        let mouseLocal = new THREE.Vector3();
        
        // Interaction State
        let lastPinchDist = null, lastMidpoint = new THREE.Vector2();
        let clickCount = 0, lastClickTime = 0;
        let recoveryStartTime = -1, recoveryFactor = 1.0;
        let targetZ = 35;
        const keys = {};

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = targetZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            setupParticles();
            
            // Unified Listeners
            window.addEventListener('pointermove', e => updateMouse(e.clientX, e.clientY));
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', () => { lastPinchDist = null; });
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);

            animate();
        }

        function setupParticles() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.height = 100;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 25px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Rodrigo', 50, 50);

            const data = ctx.getImageData(0, 0, 100, 100).data;
            const points = [];
            for (let i = 0; i < 10000; i++) {
                if (data[i * 4] > 128) points.push({ x: (i % 100 - 50) * 0.5, y: (50 - Math.floor(i / 100)) * 0.5 });
            }

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            const col = new Float32Array(PARTICLE_COUNT * 3).fill(1);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = points[Math.floor(Math.random() * points.length)];
                pos[i*3] = (Math.random()-0.5)*40;
                pos[i*3+1] = (Math.random()-0.5)*40;
                pos[i*3+2] = (Math.random()-0.5)*40;
                particleData.push({ hx: p.x, hy: p.y, hz: (Math.random()-0.5)*2, vx: 0, vy: 0, vz: 0 });
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            particles = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.15, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.9 }));
            scene.add(particles);
        }

        function updateMouse(x, y) {
            const vec = new THREE.Vector3((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1, 0.5).unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            mouseWorld.copy(camera.position).add(dir.multiplyScalar(-camera.position.z / dir.z));
        }

        function onPointerDown(e) {
            if (e.pointerType === 'touch' && !e.isPrimary) return;
            const now = performance.now();
            clickCount = (now - lastClickTime < 800) ? clickCount + 1 : 1;
            lastClickTime = now;
            if (clickCount >= 5) {
                recoveryStartTime = now;
                recoveryFactor = 0;
                particleData.forEach(p => {
                    const f = 45 + Math.random() * 85;
                    const a1 = Math.random() * Math.PI * 2, a2 = (Math.random() - 0.5) * Math.PI;
                    p.vx += Math.cos(a1) * f; p.vy += Math.sin(a1) * f; p.vz += Math.sin(a2) * f;
                });
                clickCount = 0;
            }
        }

        function onTouchStart(e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY;
                lastPinchDist = Math.sqrt(dx*dx + dy*dy);
                lastMidpoint.set((e.touches[0].clientX + e.touches[1].clientX)/2, (e.touches[0].clientY + e.touches[1].clientY)/2);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) updateMouse(e.touches[0].clientX, e.touches[0].clientY);
            else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX, dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (lastPinchDist) targetZ -= (dist - lastPinchDist) * 0.1;
                lastPinchDist = dist;

                const midX = (e.touches[0].clientX + e.touches[1].clientX)/2, midY = (e.touches[0].clientY + e.touches[1].clientY)/2;
                particles.rotation.y += (midX - lastMidpoint.x) * 0.005;
                particles.rotation.x += (midY - lastMidpoint.y) * 0.005;
                lastMidpoint.set(midX, midY);
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Time-based Recovery
            if (recoveryStartTime > 0) {
                const elapsed = (performance.now() - recoveryStartTime) / EXPLOSION_RECOVERY_TIME;
                recoveryFactor = elapsed >= 1 ? (recoveryStartTime = -1, 1) : elapsed;
            }

            // Keyboard Controls
            if (keys.ArrowUp) particles.rotation.x -= 0.03;
            if (keys.ArrowDown) particles.rotation.x += 0.03;
            if (keys.ArrowLeft) particles.rotation.y -= 0.03;
            if (keys.ArrowRight) particles.rotation.y += 0.03;
            if (!keys.ArrowUp && !keys.ArrowDown && !keys.ArrowLeft && !keys.ArrowRight && !lastPinchDist) {
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.02);
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.02);
            }

            if (keys['+'] || keys['=']) targetZ -= 0.5;
            if (keys['-']) targetZ += 0.5;
            targetZ = THREE.MathUtils.clamp(targetZ, 10, 150);
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, targetZ, 0.1);

            // Project Mouse into Local space for heatmap
            mouseLocal.copy(mouseWorld).applyMatrix4(new THREE.Matrix4().copy(particles.matrixWorld).invert());

            const pos = particles.geometry.attributes.position.array;
            const col = particles.geometry.attributes.color.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particleData[i];
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                // Heatmap & Simple Interaction (Local Space)
                const dx = mouseLocal.x - pos[ix], dy = mouseLocal.y - pos[iy], dz = mouseLocal.z - pos[iz];
                const d2 = dx*dx + dy*dy + dz*dz;
                if (d2 < MOUSE_INFLUENCE * MOUSE_INFLUENCE) {
                    const dist = Math.sqrt(d2), r = dist / MOUSE_INFLUENCE;
                    if (r < 0.5) { col[ix]=1-r/0.5; col[iy]=r/0.5; col[iz]=0; }
                    else { const t=(r-0.5)/0.5; col[ix]=t; col[iy]=1; col[iz]=t; }
                    const f = (MOUSE_INFLUENCE - dist) / MOUSE_INFLUENCE;
                    p.vx -= dx * f * 0.1; p.vy -= dy * f * 0.1;
                } else { col[ix] = col[iy] = col[iz] = 1; }

                if (recoveryStartTime > 0) {
                    pos[ix] = THREE.MathUtils.lerp(pos[ix] + p.vx, p.hx, recoveryFactor);
                    pos[iy] = THREE.MathUtils.lerp(pos[iy] + p.vy, p.hy, recoveryFactor);
                    pos[iz] = THREE.MathUtils.lerp(pos[iz] + p.vz, p.hz, recoveryFactor);
                    p.vx *= 0.95; p.vy *= 0.95; p.vz *= 0.95;
                } else {
                    p.vx = (p.vx + (p.hx - pos[ix]) * 0.08) * 0.9;
                    p.vy = (p.vy + (p.hy - pos[iy]) * 0.08) * 0.9;
                    p.vz = (p.vz + (p.hz - pos[iz]) * 0.08) * 0.9;
                    pos[ix] += p.vx; pos[iy] += p.vy; pos[iz] += p.vz;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>